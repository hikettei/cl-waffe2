<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>cl-waffe2/vm.nodes - cl-waffe2 Documentation</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "cl-waffe2/vm.nodes";
        var mkdocs_page_input_path = "nodes.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> cl-waffe2 Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../install/">Install</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../overview/">Tutorials</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../Tips/">Tips</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">cl-waffe2/vm.nodes</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#shaping-api">Shaping API</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#introducing-subscript-dsl">Introducing Subscript DSL</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#basic-grammar">Basic Grammar</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#assigned-task">Assigned task</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#determine-rules">Determine Rules</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#initial-value-of-table">Initial value of table</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#api-create-subscript-p">API: create-subscript-p</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#defnode">defnode</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#inputs">Inputs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#effects">Effects</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#useful-tips">Useful Tips</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#how-and-when-to-define-backward">How and When to define backward?</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#define-impl">define-impl</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#inputs_1">Inputs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#tips-reject-p">Tips: reject-p</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#forwardbackward">forward/backward</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#forward">forward</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#defmodel">defmodel</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#effects_1">Effects</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#inputs_2">Inputs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#example">Example</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#describe-forward-propagation">Describe Forward Propagation</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#call">call</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#with-devices">with-devices</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#example_1">Example</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#composite">Composite</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#extend-composite-class-slightly-complicated">Extend Composite Class (Slightly Complicated)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#using-defmodel-macro">Using defmodel macro</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#abstractnode">AbstractNode</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#with-instant-kernel">with-instant-kernel</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#embedding-lisp-code-for-building-time">Embedding Lisp Code for building-time.</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#embedding-lisp-code-for-compile-time">Embedding Lisp Code for compile-time.</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../generic-tensor/">cl-waffe2/vm.generic-tensor</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../base-impl/">[Functions] cl-waffe2/base-impl</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../base-impl-nodes/">[Nodes] cl-waffe2/base-impl</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../distributions/">cl-waffe2/distributions</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">cl-waffe2 Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>cl-waffe2/vm.nodes</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="formulate-neural-networks">Formulate Neural Networks</h1>
<p>The package <code>:cl-waffe2/vm.nodes</code> provides a fundamental system for building neural networks.</p>
<p>This package can be divided into three main parts.</p>
<ol>
<li>Shaping APIs</li>
<li>defnode  (Differentiable Operations)</li>
<li>defmodel (Operations consisted of defnode)</li>
</ol>
<p>Note that there's a clear distinction between node and model.</p>
<pre><code class="language-lisp">defnode  =&gt; called with `forward` 
defmodel =&gt; called with `call`
</code></pre>
<p>Also, defnode is a fundamental unit of operation, while defmodel is a set of nodes.</p>
<h2 id="shaping-api">Shaping API</h2>
<p>When defining an operation in cl-waffe2 with a <code>defnode</code> macro, the shape of the matrix used in the operation must also be defined in the <code>:where</code> keyword.</p>
<p>This is a Shaping API, and responsible for shape inspection of all operations.</p>
<h2 id="introducing-subscript-dsl">Introducing Subscript DSL</h2>
<p>I assume you have already seen <code>defnode</code> macro. This macro takes a strange syntax language after :where keyword.</p>
<pre><code class="language-lisp">(defnode (TransposeNode (myself)
            :where (A[~ i j] -&gt; A[~ j i])
         ...))

(defnode (ScalarAdd (myself)
            :where (A[~] Scal[scal] -&gt; A[~] where scal = 1)
        ...))

(defnode (ReshapeNode (myself tensor after &amp;aux (before (shape tensor)))
            :where (A[before] -&gt; A[after])
        ...))
</code></pre>
<p>This is a DSL (Domain Specific Language) called <code>Subscript DSL</code>, which is used to notate the pointer and shape to be handled before and after the operation.</p>
<p>For example, <code>TransposeNode</code> is said to be:</p>
<ol>
<li>
<p>Before and after the operation, we use the same pointer.</p>
</li>
<li>
<p>A is a tensor with more than two dimensions, and after the operation, transposed the last two axes. (i.e.: A=(10 5 2), (10 2 5) is returned)</p>
</li>
</ol>
<p><code>ScalarAdd</code> is said to be:</p>
<ol>
<li>
<p>The first argument <code>A</code> can be anything. The second argument <code>Scal</code> is a scalar tensor.</p>
</li>
<li>
<p>The returned tensor shares the pointer with the given <code>A</code>.</p>
</li>
</ol>
<p><code>ReshapeNode</code> is:</p>
<ol>
<li>
<p>Before and after the operation, pointers are common.</p>
</li>
<li>
<p>The shape of A will be transformed from <code>before</code> into <code>after</code></p>
</li>
</ol>
<h3 id="basic-grammar">Basic Grammar</h3>
<p>Let's start with learning the grammar.</p>
<p>One line code of Subscript DSL follows this format:</p>
<pre><code>[Before The Operation] -&gt; [After The Operation] where [symbol = expression (Optional)] ...
</code></pre>
<p>Note that:</p>
<ol>
<li>
<p>the pharse <code>where [symbol = expression (Optional)] ...</code> is <strong>Optional</strong></p>
</li>
<li>
<p>One Subscript DSL place can include one line of code.</p>
</li>
<li>
<p>[Before The Operation] and [After The Operation] has the common grammar rule.</p>
</li>
</ol>
<p>Let <code>&lt;Arguments&gt;</code> be a grammar rule of [Before The Operation] and [After The Operation], <code>&lt;Arguments&gt;</code> can be defined as:</p>
<pre><code>&lt;Arguments&gt; ::= &lt;Arguments&gt; &lt;Argument&gt;
&lt;Argument&gt; ::= &lt;PointerName&gt; [ &lt;SubScripts&gt; ] | NIL

&lt;PointerName&gt; ::= Symbol // the same as CL's symbol.

&lt;SubScripts&gt;  ::= &lt;Subscripts&gt; &lt;Subscript&gt;
&lt;Subscript&gt;   ::= Symbol | NIL
</code></pre>
<p>To put it bluntly, <Argument> can be a sequence of:</p>
<pre><code class="language-c">PointerName[SubScripts]

// SubScripts can be one of: [A], [A B] [~ i j] etc...
</code></pre>
<h3 id="assigned-task">Assigned task</h3>
<pre><code>A[a b] B[a b] -&gt; B[a b]
</code></pre>
<p>In the DSL above, <code>A</code> and <code>B</code> indicates the name of pointer, they're not needed to be defined in advance.</p>
<p>On the other hand <code>a</code> and <code>b</code> inside [ ... ], indicates subscripts of <code>A</code> and <code>B</code>, DSL's assigned work is to inference these <strong>undetermined symbols</strong> from:</p>
<ol>
<li>
<p>determined symbol from <code>where</code> pharse and symbols in arguments of constructor.</p>
</li>
<li>
<p>Shape of the given inputs at runtime.</p>
</li>
</ol>
<p>If any, DSL compiles and display a report on <code>Shape-Error</code> before performing the operation.</p>
<pre><code class="language-lisp">(!add (randn `(3 2)) (randn `(2 4)))
;; will produce...

[cl-waffe] Shaping-Error: Couldn't step forward because of shape-error.

The operation was : &lt;Node: ADDNODE-CPUTENSOR (A[~] B[~] -&gt; A[~])&gt;

Input(s)            : ((3 2) (2 4))
Predicted Output(s) : ((3 2))

Here's a list of reports.

1. Couldn't idenfity ~: ~ is determined as 3 
 butgot: 2.
 Excepted ~ = (3 2), butgot: (2 4)

Also, these reports could be helpful for you (calculated ignoring the first errors.)

2. Couldn't idenfity ~: ~ is determined as 2 
 butgot: 4.
 Excepted ~ = (3 2), butgot: (2 4)
</code></pre>
<h3 id="determine-rules">Determine Rules</h3>
<pre><code>(defnode (ExampleNode (myself)
            :where (A[~ i j] B[~ j k] C[~ k i] -&gt; C[~ k i])
         ...))
</code></pre>
<p>Symbols used in subscripts has a two state:</p>
<ol>
<li>
<p>Determined (those that can say i=1, j=2!)</p>
</li>
<li>
<p>Undetermined (those that cannot say i=1, j=2)</p>
</li>
</ol>
<p>Before doing <code>(call (ExampleNode) ...)</code>, we create a table which stores determined/undetermined symbols and corresponding values.</p>
<pre><code>[TABLE]
~  -&gt; ? // Undetermined before runtime
i  -&gt; ? // Undetermined before runtime
j  -&gt; ? // Undetermined before runtime
k  -&gt; ? // Undetermined before runtime
</code></pre>
<p>The moment we do <code>(call (ExampleNode) TensorA TensorB TensorC)</code>, we will be able to inference the value of <code>i</code> <code>j</code> <code>k</code> from the shape of given TensorA, TensorB, and TensorC.</p>
<p>For Example, Let TensorA be a <code>2x3x4</code> Matrix, then the table become:</p>
<pre><code>[TABLE]
~  -&gt; 2
i  -&gt; 3
j  -&gt; 4
k  -&gt; ? 
</code></pre>
<p>Then continue to do the same thing for TensorB. Let TensorB be a <code>2x4x9</code> Matrix, then the table become:</p>
<pre><code>[TABLE]
~ -&gt; 2
i -&gt; 3
j -&gt; 4
k -&gt; 9
</code></pre>
<p>Last, applying this operation into TensorC, but what if I gave the wrong shape to TensorC? Let TensorC be a <code>999x999x999</code> Matrix. (Obviously this is wrong).</p>
<pre><code>[TABLE]
~ -&gt; 2 // ≠999
i -&gt; 3 // ≠999
j -&gt; 4 // ≠999
k -&gt; 9 // ≠999
</code></pre>
<p>All subscripts in the table do not match with 999, resuting in shape-error.</p>
<p>In that case, we can try again the operation with giving the correct shape to TensorC. Let TensorC be <code>2x9x3</code> Matrix.</p>
<pre><code>[TABLE]
~ -&gt; 2 // =2
i -&gt; 3 // = 3
j -&gt; 4 // 
k -&gt; 9 // = 9
</code></pre>
<p>All subscripts passed! (puts error If there's still undetermined symbol.)</p>
<p>Using the determined table, we can also inference the shape of output tensor. The returned tensor is the shape of <code>(~ k i)</code>, that is, <code>(2 9 3)</code>. This operation can be done in a chain of lazy-evaluated nodes.</p>
<p>Now, moving on to another topic, subscripts can be one of them.</p>
<pre><code>[TABLE]

a = 1 // Fixnum

b = `(1 2) // List consisted of fixnum

~ = `(1 2 3) // ~ is a special symbol which represents batched-input.
</code></pre>
<p>DSL flattens the list in the subscript. (e.g.: <code>b=(1 2)</code> in <code>A[b]</code> is the equivalent to <code>A[1 2]</code>)</p>
<p><strong>Note that</strong> ~ is a reserved word by cl-waffe2 and has a special rule:</p>
<ol>
<li>
<p>~ is used to express dimensions from 0 to N</p>
</li>
<li>
<p>~ can only be used once for one input of subscript.</p>
</li>
<li>
<p>In tables, ~ is interpreted as one of: <code>NIL</code> or <code>List</code></p>
</li>
</ol>
<p>In addition, ~ has a three behaviour:</p>
<ol>
<li>
<p>If ~ never appears in [Before The Operation] and [After The Operation] parts, the length of ~ could be Any.</p>
</li>
<li>
<p>If ~ appears more than once, the length of ~ and content should be common.</p>
</li>
<li>
<p>If ~ appears only in [After The Operation], returns error because we can't determine ~.</p>
</li>
</ol>
<p>In conclusion, I believe introducing Subscript DSL produces two benefits:</p>
<ol>
<li>
<p>Rigorous Shape Inspection in all operations with small code, and produce better Shape-Error (Initially I'm inspired in: <a href="https://github.com/dimforge/nalgebra">nalgebra</a>).</p>
</li>
<li>
<p>JIT Compiler can use a shape of given arguments in advance. (If only CL has a const-generics like Rust, Subscript DSL isn't needed anymore!).</p>
</li>
</ol>
<h3 id="initial-value-of-table">Initial value of table</h3>
<p>In order to give a initial value to tables, you can declare symbols with initial value.</p>
<p><strong>Using where pharse in :where form</strong></p>
<p>Add this form to your <code>:where</code> form.</p>
<pre><code class="language-lisp">;; Syntax is that: Symbol-Name = Expression

(defnode (...
    :where (A[i] B[j] -&gt; C[k] where i = 1 j = 2 k = 3)
    ....
</code></pre>
<p>will produce:</p>
<pre><code>[TABLE]
i = 1
j = 2
k = 3
</code></pre>
<p>Using arguments declared in <code>constructor</code>.</p>
<pre><code class="language-lisp">(defnode (ExampleNode (self i)
             :where (A[~] -&gt; A[i]))
        ...)
</code></pre>
<p>Arguments used in constructor, will automatically interpreted as <code>initial value</code>. (e.g.: <code>i</code> is a initial value.)</p>
<pre><code>[TABLE]
~ = ?
i = i
</code></pre>
<p>That is, when <code>ExampleNode</code> is initialized with <code>(ExampleNode 3)</code>, the table become:</p>
<pre><code>[TABLE]
~ = ?
i = 3
</code></pre>
<ol>
<li>arguments of constructor</li>
</ol>
<h3 id="api-create-subscript-p">API: create-subscript-p</h3>
<p><code>(create-subscript-p subscripts &amp;key macroexpand fixed return-body)</code></p>
<p>Inputs:</p>
<ol>
<li>
<p>macroexpand[Boolean] If t, displays the generated program.</p>
</li>
<li>
<p>fixed[Boolean] If t, ~ is ignored.</p>
</li>
<li>
<p>return-body[Boolean] If t, the returned is S-exp.</p>
</li>
</ol>
<p>Outputs:</p>
<p><code>(values compiled-function To-Refer-Pointer-Idx Broadcastable_List)</code></p>
<p>Example: (TODO)</p>
<h2 id="defnode">defnode</h2>
<pre><code class="language-lisp">(defnode ((abstract-name
           (self &amp;rest constructor-arguments)
            &amp;key
              (where t)
              (out-scalar-p nil)
              (slots nil)
              (backward nil)
              (documentation &quot;&quot;))
           &amp;body constructor-body))
</code></pre>
<p>defnode is a macro which is used to define a subclass of <code>AbstractNode</code>.</p>
<p>The defined class is named after <code>abstract-name</code>, which has:</p>
<ol>
<li>
<p>Subscript DSL</p>
</li>
<li>
<p>Slots that are shared at forward/backward time.</p>
</li>
<li>
<p>Generic definition of backward</p>
</li>
</ol>
<h3 id="inputs">Inputs</h3>
<ol>
<li>
<p><code>abstract-name</code> the class is named after it</p>
</li>
<li>
<p><code>where</code>  the place to put Subscript DSL</p>
</li>
<li>
<p><code>backward</code> the general definition of backward (Optional). Place S-expression here If you wanna ignore define-impl's backward, otherwise define-impl's one is used.</p>
</li>
<li>
<p><code>documentation</code> docstring</p>
</li>
<li>
<p><code>out-scalar-p</code> Set t If the returned tensor is ScalarTensor. This can be dynamically modified via the accessor <code>(out-scalar-p self)</code>.</p>
</li>
</ol>
<h3 id="effects">Effects</h3>
<ol>
<li>
<p>Defines a class named <code>abstract-name</code></p>
</li>
<li>
<p>Defines a function which is used to initialize the node named <code>abstract-name</code></p>
</li>
</ol>
<h3 id="useful-tips">Useful Tips</h3>
<p>In order to simplify parameter initialisation, if the keyword name of the :initarg is the same as the keyword name of the argument, the initialisation code is automatically generated.</p>
<pre><code class="language-lisp">(defnode (ExampleNode (self arg)
            :slots ((arg :initarg :arg))))

(slot-value (ExampleNode 10) 'arg) ;; =&gt; 10
</code></pre>
<h3 id="how-and-when-to-define-backward">How and When to define backward?</h3>
<p>The backward follows this format:</p>
<pre><code class="language-lisp">((self dout dx dy ... dn)
 (values dx.grad dy.grad ... dn.grad))
</code></pre>
<p><code>dout</code> is a previous node's gradient, and <code>dx dy ... dn</code> is a variables that used when forward. No guarantee that <code>dx dy ... dn</code> isn't being destructed due to in-place operation. If you need them in order to compute gradients, set <code>:save-for-backward (t t ... t)</code> at <code>define-impl</code> macro.</p>
<p>Find the partial derivative of each variable according to the derivative of the composite function.</p>
<p>The definition of backward must be placed either of defnode or define-impl.
Basically, if the original defnode describes the backward, define-impl's backward is ignored.</p>
<pre><code class="language-lisp">1.
=================================================================
AddNode (defnode) &lt;- Place Backward
   |
   |-&gt; (AddNode :CPUTensor)  (define-impl)
   |-&gt; (AddNode :LispTensor) (define-impl)
   |-&gt; (AddNode :CUDATensor) (define-impl)
=================================================================

2.
=================================================================
AddNode (defnode) &lt;- Backward=nil
   |
   |-&gt; (AddNode :CPUTensor)  (define-impl) &lt;- place backward
   |-&gt; (AddNode :LispTensor) (define-impl) &lt;- place backward
   |-&gt; (AddNode :CUDATensor) (define-impl) &lt;- place backward
=================================================================
</code></pre>
<p>Depending on <code>*using-backend*</code>, the implementation to use is determined at node-building time. See also: with-devices.</p>
<h2 id="define-impl">define-impl</h2>
<pre><code class="language-lisp">(define-impl ((abstract-name
            &amp;key
              (device t)
              (reject-p nil))
               &amp;key
             save-for-backward
             forward
             backward)
</code></pre>
<p>Defines a implementation of AbstractNode of <code>device</code>.</p>
<h3 id="inputs_1">Inputs</h3>
<ol>
<li>
<p><code>device</code> Set here symbol the impl working on. The symbol must be a subclass of <code>AbstractTensor</code>. If t, the impl has the highest priority assigned to all implementations.</p>
</li>
<li>
<p><code>reject-p[null or predicate]</code> Set here predicator, If the predicator is t, the implementation refures to be dispatched.</p>
</li>
<li>
<p><code>save-for-backward</code> The corresponding variable which is t will be made a copy when forward. (e.g.: <code>forward=(x y)</code> and <code>save-for-backward=(t nil)</code>, x is copied, y isn't copied.)</p>
</li>
<li>
<p><code>forward</code> Place the expanded lisp-code for forward propagation.</p>
</li>
<li>
<p><code>backward</code> Place the definition of backward as the same forward of <code>defnode</code> does.</p>
</li>
</ol>
<h3 id="tips-reject-p">Tips: reject-p</h3>
<p>One of the practical usage of reject-p is to restrict dtypes that implementation can handle.</p>
<p>reject-p takes an function: #'(lambda (&amp;rest inputs) ...) where inputs is <code>constructor-arguments</code> in defnode. (e.g.: <code>(AddNode :float)</code> -&gt; <code>inputs=(list :float)</code>).</p>
<p><code>AddNode</code> for CPUTensor only supports dense matrix.</p>
<pre><code class="language-lisp">(define-impl (AddNode :device CPUTensor
         :reject-p (supported-dtypes-are 0 :float :double))
         :forward ((self x y)
               `(,@(expand-axpy-form x y)
                 ,x)))
</code></pre>
<p>The macro <code>supported-dtypes-are</code> returns an predicator which returns nil if the first argument is the equivalent to <code>:float</code> or <code>:double</code>.</p>
<h3 id="forwardbackward">forward/backward</h3>
<p>forward/backward is given as:</p>
<pre><code class="language-lisp">((self &amp;rest arguments)
 body)
</code></pre>
<h2 id="forward">forward</h2>
<p><code>(forward node &amp;rest inputs)</code>
Step forward of the given <code>node</code>, node is a subclass of <code>AbstractNode</code>.</p>
<p>Note that <code>forward</code> can't handle with <code>Composite</code>.</p>
<h2 id="defmodel">defmodel</h2>
<pre><code>(defmodel ((name
         (self-name &amp;rest constructor-arguments)
              &amp;key
               (slots nil)
               (initargs)
               (on-call-&gt; nil)
               (documentation &quot;&quot;))
            &amp;body constructor-body)
</code></pre>
<p>defmodel is a macro used to describe the model of neural network with <code>Composite</code> class.</p>
<h3 id="effects_1">Effects</h3>
<ol>
<li>
<p>defines a class named <strong>name</strong></p>
</li>
<li>
<p>defines a function named <strong>name</strong> with the constructor-arguments and constructor-body.</p>
</li>
</ol>
<h3 id="inputs_2">Inputs</h3>
<ol>
<li>name[Symbol]  All models, and constructors for the model, are named after it.</li>
<li>
<p>(self-name &amp;rest constructor-arguments)
    The constructor function is defined as:
    (defun ,name (self-name ,@constructor-arguments)
       ...)</p>
</li>
<li>
<p>slots ((slot-option1) (slot-option2) ...)
    Parameters of the inherited Composite class. It has the same syntax as defclass slots</p>
</li>
<li>
<p>initargs (:accessor-name1 accessor-init-form1 :accessor-name2 accessor-init-form2 ...
    Unlike CL's structure, classes are tend to rebundant when writing the process of initializing slots. To make this simple, this argument was introduced. It works like a structure's constructor!</p>
</li>
<li>
<p>documentation[String]</p>
</li>
<li>
<p><code>on-call-&gt;</code> [One of: nil symbol-name function list]
     on-call-&gt; is used to control the behaviour of <em>call</em> function.</p>
</li>
</ol>
<h3 id="example">Example</h3>
<pre><code class="language-lisp">(defmodel (ExampleLayer (self features)
               ;; Options/Utils Here,
               :slots    ((param :initarg :param))
               :initargs (:param (make-tensor `(,features) :requires-grad t))
               :documentation &quot;ExampleLayer is a ...&quot;)

    ;; After make-instance is called, the form below is called.
    ;; make-instance -&gt; make-instance :after -&gt; this form.

    (print self)     ;; &lt;- Initialized ExampleLayer
    (print features) ;; &lt;- constructor-arguments are also used here.
    (print &quot;ExampleLayer is created!&quot;))

;; The model you created, works like:
(let ((layer (ExampleLayer 10)))
    (call layer ...))
</code></pre>
<h3 id="describe-forward-propagation">Describe Forward Propagation</h3>
<p>The option <code>on-call-&gt;</code> can control the behaviour of <em>call</em> function.</p>
<p><code>on-call-&gt;</code> could be one of these case:</p>
<p>First case,  <code>on-call-&gt;</code> is nil:</p>
<p>cl-waffe2 calls the <strong>call</strong> function when doing forward propagation of the model.</p>
<p>Second case, <code>on-call-&gt;</code> is symbol-name:</p>
<p>cl-waffe2 calls the specified function at on-call-&gt; parameter, when doing forward propagation of the model.</p>
<p>symbol-name could be also one of: method's name function's name.</p>
<p>For example, set <code>:on-call-&gt; = call-example-layer</code> which defined as:</p>
<pre><code class="language-lisp">   (defmethod call-example-layer ((model ExampleLayer) x y)
       (print &quot;call-example-layer is used!&quot;)
       ...)
</code></pre>
<pre><code class="language-lisp">   (call (ExampleLayer 10) tensor) ;; call-example-layer is used!
</code></pre>
<p>(Complicated model assignments like ConvND, for example, can be achieved by assigning generic function names to symbols.)</p>
<p>[Third case] <code>on-call-&gt;</code> is function (i.e.: lambda):</p>
<p>cl-waffe2 calls the given lambda function as a forward propagation.</p>
<p>[Fourth case] <code>on-call-&gt;</code> is a list:</p>
<p>The List, should be this format.</p>
<p><code>((arguments) body)</code></p>
<p>This argument is expanded into <code>#'(lambda ,@on-call-&gt;)</code> and works as well as 3.</p>
<h2 id="call">call</h2>
<p>All models in cl-waffe2, should implement this generic function. This generic function returns the computation node of the forward propagation of the model.</p>
<p>The generic function call is also used to step forward of AbstractNode, that is, works as if forward.</p>
<p><code>[generic-function]</code> (call model &amp;rest inputs)</p>
<h2 id="with-devices">with-devices</h2>
<p>The macro with-devices declares the node's priority for the function <em>forward</em> to be used.</p>
<p>Input:
   - backend-priority
     An list of device's name (e.g.: CPUTensor, LispTensor...)
     Devices on the left have higher priority.</p>
<p>Example:</p>
<p>Let ATensor and BTensor be compatible (i.e.: pointers are the same type), and subclass of AbstractNode, and all the operations they have are as follows:</p>
<ol>
<li>ATensor has !add.</li>
<li>BTensor has !mul.</li>
</ol>
<p>This code works:</p>
<p>(setq a (make-tensor `(10 10))) ;; The tensor a is ATensor.</p>
<p>;; (Priority1=ATensor Priority2=BTensor)
(with-devices (ATensor BTensor)
   (!add a (!mul a a)))</p>
<p>ATensor doesn't have any implementation of !mul, but it does work. This is because cl-waffe2's compatible backend system.</p>
<p>cl-waffe2's backend dispatching rule is following:</p>
<p>If the priority 1 backend does not have an implementation of the specified operation, check if the priority 2 backend does, if it still does not have it, 3, 4... and so on.</p>
<p>The order of priority would be `(,@backend-priority ScalarTensor t). (t is a special name, and it implys the implement works for all the backends.)</p>
<h3 id="example_1">Example</h3>
<pre><code class="language-lisp">(with-devices (LispTensor CPUTensor)
   (!add a b))
</code></pre>
<h2 id="composite">Composite</h2>
<p>[class] Composite</p>
<p>Composite is a fundamental datatype for all neural network models. The name composite is so named because it is used to bundle computation nodes constructed by defnode.</p>
<p>In cl-waffe2, All models should be a subtype of this class, and shall return a forward propagation computation node using the <strong>call</strong> function.</p>
<p>In order to define your model with Composite, two methods are available.</p>
<h3 id="extend-composite-class-slightly-complicated">Extend Composite Class (Slightly Complicated)</h3>
<p>First, define your class with extending Composite Class.</p>
<pre><code class="language-lisp">(defclass LinearModel (Composite)
   ((weight ...) ; &lt;- set parameters here.
    (bias   ...))
</code></pre>
<p>Second, define forwarrd step with overriding call method.</p>
<pre><code class="language-lisp">(defmethod call ((model LinearModel) &amp;rest inputs)
     ... )
</code></pre>
<p>It should work like:</p>
<p><code>(call (make-instance 'LinearModel in-features out-features) args1 ...)</code></p>
<h3 id="using-defmodel-macro">Using defmodel macro</h3>
<p>The defmodel macro simplifies the above redundant notation and also solves the problem that call can only use &amp;rest as an argument. Therefore, I'm depcrecated with the method above, instead, use defmacro. For detailed usage, see the documentation of defmacro.</p>
<h2 id="abstractnode">AbstractNode</h2>
<p>[class] AbstractNode</p>
<p>The class AbstractNode is a fundamental object of describing computation nodes in cl-waffe.</p>
<p>AbstractNode must possess following:</p>
<ol>
<li>
<p>Transimission State</p>
</li>
<li>
<p>Slots (for passing forward/backward)</p>
</li>
<li>
<p>Variables (for building computation nodes)</p>
</li>
</ol>
<h2 id="with-instant-kernel">with-instant-kernel</h2>
<p>Creates an instant-kernel following tensor.</p>
<p>This macro is used to embed condition-free Lisp code either in the process of creating a node or after it has been compiled.</p>
<p>Use case:</p>
<h3 id="embedding-lisp-code-for-building-time">Embedding Lisp Code for building-time.</h3>
<pre><code class="language-lisp">(setq a (randn `(10 10)))
(with-instant-kernel a
    (print a)) ;; -&gt; (print a) is evaluated
</code></pre>
<h3 id="embedding-lisp-code-for-compile-time">Embedding Lisp Code for compile-time.</h3>
<pre><code class="language-lisp">(setq a (randn `(10 10)))
(with-instant-kernel a
    `(print ,a)) ;; -&gt; (print a) isn't evaluated

(funcall (build *)) ;; -&gt; (print a) will be evaluated.
</code></pre>
<p>Note that (equal (with-instant-kernel a) a) is NIL, that is, the returned value of this macro must be followed by a calculation node.</p>
<p>If the return value of Body can be expanded as a macro, the values are compiled together at JIT compile time. Otherwise, the given tensor is returned as is.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../Tips/" class="btn btn-neutral float-left" title="Tips"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../generic-tensor/" class="btn btn-neutral float-right" title="cl-waffe2/vm.generic-tensor">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../Tips/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../generic-tensor/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
