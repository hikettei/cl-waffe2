<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>cl-waffe2 - cl-waffe2 Documentation</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "cl-waffe2";
        var mkdocs_page_input_path = "utils.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> cl-waffe2 Documentation
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Overview</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../install/">Install</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../examples/">Examples</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../overview/">Learn More</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">cl-waffe2</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#tensor-facet-converting-abstracttensor-anything">[Tensor Facet] Converting AbstractTensor &lt;-&gt; Anything</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#generic-convert-tensor-facet">[generic] convert-tensor-facet</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#inputs">Inputs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#adding-an-extension">Adding an extension</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#example">Example</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#function-change-facet">[function] change-facet</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#standard-directions">Standard Directions</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#function-device-as">[function] device-as</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#example_1">Example</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#function-tensor">[function] -&gt;tensor</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#example_2">Example</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#macro-with-facet">[macro] with-facet</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#example_3">Example</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#macro-with-facets">[macro] with-facets</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#advanced-network-construction">Advanced Network Construction</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#function-asnode">[function] asnode</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#usage-call-">Usage: call-&gt;</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#usage2-defmodel-as">Usage2: defmodel-as</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#macro-repeatn">[macro] RepeatN</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#example_4">Example</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#function-call-">[function] call-&gt;</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#macro-defsequence">[macro] defsequence</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#inputs_1">Inputs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#example_5">Example</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#macro-hooker">[macro] hooker</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#example_6">Example</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#macro-node-lambda">[macro] node-&gt;lambda</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#inputs_2">Inputs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#example_7">Example</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#note">Note</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#macro-node-defun">[macro] node-&gt;defun</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#inputs_3">Inputs</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#example_8">Example</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#function-show-backends">[function] show-backends</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#example_9">Example</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#function-set-devices-toplevel">[function] set-devices-toplevel</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../nodes/">cl-waffe2/vm.nodes</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../generic-tensor/">cl-waffe2/vm.generic-tensor</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../vm/">cl-waffe2/vm</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../base-impl/">[Functions] cl-waffe2/base-impl</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../base-impl-nodes/">[Nodes] cl-waffe2/base-impl</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../distributions/">cl-waffe2/distributions</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../nn/">cl-waffe2/nn</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../optimizer/">cl-waffe2/optimizers</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../lisp-tensor-backend/">cl-waffe2/backends.lisp</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../cpu-tensor-backend/">cl-waffe2/backends.cpu</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../cpu-jit-tensor-backend/">cl-waffe2/backends.jit.cpu</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">cl-waffe2 Documentation</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a> &raquo;</li>
      <li>cl-waffe2</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="package-cl-waffe2">[package] cl-waffe2</h1>
<p>The <code>cl-waffe2</code> package provides utilities for a wide range needs: Object Convertion, Advance Network Construction, Trainer, and so on.</p>
<h2 id="tensor-facet-converting-abstracttensor-anything">[Tensor Facet] Converting AbstractTensor &lt;-&gt; Anything</h2>
<p>If you're looking for the way to create an AbstractTensor from a Common Lisp array or manipulate an AbstractTensor as a Common Lisp array, this section is perfect for you. Here we provide a common APIs for the conversion between AbstractTensor and other matrix types. The most basic method is a <code>convert-tensor-facet</code> method and we're welcome to add a new method by users. Other functions are macros work by assigning a method according to the type of object and the direction. Plus, conversions are performed while sharing pointers as much as possible. If turned out to be they can't be shared, the with-facet macro forces a copy to be performed and pseudo-synchronises them.</p>
<h2 id="generic-convert-tensor-facet">[generic] convert-tensor-facet</h2>
<pre><code class="language-lisp">(convert-tensor-facet from to)
</code></pre>
<p>Converts the given object (anything is ok; from=<code>AbstractTensor</code> <code>simple-array</code> etc as long as declared) into the direction indicated in <code>to</code>.</p>
<h3 id="inputs">Inputs</h3>
<p><code>From[Anything]</code> The object to be converted</p>
<p><code>To[Symbol]</code> Indicates to where the object is converted</p>
<h3 id="adding-an-extension">Adding an extension</h3>
<p>Welcome to define the addition of method by users. For example, <code>Fixnum -&gt; AbstractTensor</code> convertion can be written like:</p>
<pre><code class="language-lisp">(defmethod convert-tensor-facet ((from fixnum) (to (eql 'AbstractTensor)))
    (make-tensor from))

(print (change-facet 1 :direction 'AbstractTensor))

;;{SCALARTENSOR[float]   
;;    1.0
;;  :facet :exist
;;  :requires-grad NIL
;;  :backward NIL} 
</code></pre>
<p>If any object to AbstractTensor conversion is implemented, it is strongly recommended to add it to this method.</p>
<h3 id="example">Example</h3>
<pre><code class="language-lisp">(convert-tensor-facet (randn `(3 3)) 'simple-array)
</code></pre>
<p>See also: <code>convert-facet (more convenient API)</code></p>
<h2 id="function-change-facet">[function] change-facet</h2>
<pre><code class="language-lisp">(change-facet (array-from &amp;key (direction 'array)))
</code></pre>
<p>By calling the <code>conver-tensor-facet</code> method, this function can change the facet of given <code>array-form</code> into the <code>direction</code>. (Just an alias of <code>(convert-tensor-facet array-from direction)</code>)</p>
<p>See also: <code>convert-tensor-facet</code></p>
<h3 id="standard-directions">Standard Directions</h3>
<p>We provide these symbols as a <code>direction</code> in standard.</p>
<ul>
<li>
<p><code>array</code>: Any Object -&gt; Common Lisp Standard ND Array</p>
</li>
<li>
<p><code>simple-array</code>: Any Object -&gt; Common Lisp Simple-Array</p>
</li>
<li>
<p><code>AbstractTensor</code>: Any Object -&gt; AbstractTensor. If couldn't determine the dtype, dtype of the first element of <code>array-from</code> is used instead.</p>
</li>
</ul>
<h2 id="function-device-as">[function] device-as</h2>
<pre><code class="language-lisp">(device-as tensor as)
</code></pre>
<p>Converts the given AbstractTensor as <code>as</code>.</p>
<h3 id="example_1">Example</h3>
<pre><code class="language-lisp">(device-as (randn `(3 3)) :as 'CPUTensor)
</code></pre>
<h2 id="function-tensor">[function] -&gt;tensor</h2>
<p>Using the <code>convert-tensor-facet</code> method, converts the given object into AbstractTensor.</p>
<h3 id="example_2">Example</h3>
<pre><code class="language-lisp">(-&gt;tensor #2A((1 2 3) (4 5 6)))
</code></pre>
<h2 id="macro-with-facet">[macro] with-facet</h2>
<pre><code class="language-lisp">(with-facet (var (object-from &amp;key (direction 'simple-array)) &amp;body body))
</code></pre>
<p>By using the convert-tensor-facet<code>method, this macro changes the facet of</code>object-from<code>into the</code>direction<code>. If you want to apply any operations to</code>object-from<code>and ensure that modifications are applied to the</code>object-from<code>, set</code>sync<code>=t and moves element forcibly (only available when direction=</code>'abstracttensor`). This is useful when editing AbstractTensor or calling other libraries without making copies.</p>
<p>For a more explict workflow, see below:</p>
<pre><code class="language-lisp">    [macro with-facet]
            ↓
[Binding var = (convert-tensor-facet object-from direction)] 
            ↓
      [Processing body]
            ↓
[If sync=t, (setf (tensor-vec object-from) (tensor-vec (convert-tensor-facet var 'AbstractTensor)))]
</code></pre>
<h3 id="example_3">Example</h3>
<pre><code class="language-lisp">(let ((a (randn `(3 3))))
    (with-facet (a* (a :direction 'simple-array))
        (print a*)
        (setf (aref a* 0) 10.0))
   a)

;; Operations called with simple-array a*, also effects on a.

#(0.92887694 -0.710253 1.2339028 -0.78008 1.6763965 0.93389416 -0.5691122
  1.6552123 -0.108502984) 
{CPUTENSOR[float] :shape (3 3)  
  ((10.0         -0.710253    1.2339028)
   (-0.78008     1.6763965    0.93389416)
   (-0.5691122   1.6552123    -0.108502984))
  :facet :exist
  :requires-grad NIL
  :backward NIL}
</code></pre>
<p>See also: <code>with-facets</code></p>
<h2 id="macro-with-facets">[macro] with-facets</h2>
<p>Bundles several <code>with-facet</code> macro.</p>
<pre><code class="language-lisp">(with-facets ((a ((randn `(3 3)) :direction 'array))
              (b ((randn `(3 3)) :direction 'array)))
    (print a)
    (print b))
#2A((-0.020553567 -0.016298171 -2.0616999)
    (0.68268335 0.33567926 -0.79862773)
    (1.7132819 0.8081283 0.47327513)) 
#2A((-0.9344233 0.3149136 -0.8516832)
    (0.17137305 -0.026806794 -0.8192844)
    (0.19916026 -0.5102597 1.1834184)) 
</code></pre>
<h2 id="advanced-network-construction">Advanced Network Construction</h2>
<p>Powerful macros in Common Lisp enabled me to provide an advanced APIs for make the construction of nodes more systematic, and elegant. Computational nodes that are lazy evaluated can be treated as pseudo-models, for example, even if they are created via functions. And, APIs in this section will make it easy to compose/compile several nodes.</p>
<h2 id="function-asnode">[function] asnode</h2>
<pre><code class="language-lisp">(asnode function &amp;rest arguments)
</code></pre>
<p>Wraps the given <code>function</code> which excepted to create computation nodes with the <code>Encapsulated-Node</code> composite. That is, functions are regarded as a <code>Composite</code> and be able to use a variety of APIs (e.g.: <code>call</code>, <code>call-&gt;</code>, <code>defmodel-as</code> ...).</p>
<p>In principle, a function takes one argument and returns one value, but by adding more <code>arguments</code> the macro automatically wraps the function to satisfy it. For example, <code>(asnode #'!add 1.0) is transformed into: #'(lambda (x) (!add x 1.0))</code>. So the first arguments should receive AbstractTensor.</p>
<h3 id="usage-call-">Usage: call-&gt;</h3>
<p>It is not elegant to use <code>call</code> more than once when composing multiple models.</p>
<pre><code class="language-lisp">(call (AnyModel1)
      (call (AnyModel2)
             (call (AnyModel3) X)))
</code></pre>
<p>Instead, you can use the <code>call-&gt;</code> function:</p>
<pre><code class="language-lisp">(call-&gt; X
        (AnyModel1)
        (AnyModel2)
        (AnyModel3))
</code></pre>
<p>However, due to constrains of <code>call</code>, it is not possible to place functions here. <code>asnode</code> is exactly for this!</p>
<pre><code class="language-lisp">(call-&gt; X
        (AnyModel1)
        (asnode #'!softmax)
        (asnode #'!view 0) ;; Slicing the tensor: (!view x 0 t ...)
        (asnode #'!add 1.0) ;; X += 1.0
        (asnode !matmul Y) ;; X &lt;- Matmul(X, Y)
        )
</code></pre>
<h3 id="usage2-defmodel-as">Usage2: defmodel-as</h3>
<p>The macro <code>cl-waffe2/vm.nodes:defmodel-as</code> is able to define new functions/nodes from existing <code>Composite</code>. However, this macro only needs the traced computation nodes information to do this. As the simplest case, compiling the AbstractNode <code>SinNode</code> (which is callable as <code>!sin</code>) into static function, <code>matrix-sin</code>.</p>
<pre><code class="language-lisp">
;; The number of arguments is anything: (defmodel-as (asnode #'(lambda (x y z) ... is also ok

(defmodel-as (asnode #'!sin) :where (A[~] -&gt; B[~]) :asif :function :named matrix-sin)

(matrix-sin (ax+b `(10 10) 0 1)) ;; &lt;- No compiling overhead. Just works like Numpy
</code></pre>
<p>On a side note: <code>Encapsulated-Node</code> itself doesn't provide for <code>:where</code> declaration, but you can it with the keyword <code>:where</code>.</p>
<h2 id="macro-repeatn">[macro] RepeatN</h2>
<p>Creates an encapsulated node which repeats the given nodes for N times.</p>
<h3 id="example_4">Example</h3>
<pre><code class="language-lisp">(defsequence NCompose (N)
    (RepeatN N
        (asnode #'!sin)
        (asnode #'!cos)))

(cl-waffe2:dprint (call (NCompose 2) (randn `(3 10))))
Op:COSNODE{CPUTENSOR}
 |Op:SINNODE{CPUTENSOR}
   |Op:COSNODE{CPUTENSOR}
     |Op:SINNODE{CPUTENSOR}
       |&lt;TMP:CPUTENSOR&gt;TID398579(3 10)
       |Op:MOVETENSORNODE{CPUTENSOR}
         |&lt;Input:CPUTENSOR&gt;TID398582(3 10)
     |Op:MOVETENSORNODE{CPUTENSOR}
       |&lt;Input:CPUTENSOR&gt;TID398599(3 10)
   |Op:MOVETENSORNODE{CPUTENSOR}
     |&lt;Input:CPUTENSOR&gt;TID398620(3 10)
 |Op:MOVETENSORNODE{CPUTENSOR}
   |&lt;Input:CPUTENSOR&gt;TID398637(3 10)
</code></pre>
<h2 id="function-call-">[function] call-&gt;</h2>
<pre><code class="language-lisp">(call-&gt; input &amp;rest nodes)
</code></pre>
<p>Starting from <code>input</code>, this macro applies a composed function.</p>
<pre><code class="language-lisp">(call-&gt; (randn `(3 3))       ;; To the given input:
    (asnode #'!add 1.0)  ;;  |
    (asnode #'!relu)     ;;  | Applies operations in this order.
    (asnode #'!sum))))   ;;  ↓
</code></pre>
<p><code>nodes</code> could be anything as long as the <code>call</code> method can handle, but I except node=<code>Composite</code>, <code>AbstractNode</code>, and <code>(asnode function ...)</code>.</p>
<h2 id="macro-defsequence">[macro] defsequence</h2>
<pre><code class="language-lisp">(defsequence (name (&amp;rest args) &amp;optional docstring &amp;rest nodes))
</code></pre>
<p>Defines a Composite that can be defined only by the <code>call-&gt;</code> method.</p>
<h3 id="inputs_1">Inputs</h3>
<p><code>name[symbol]</code> defines the new Composite after <code>name</code></p>
<p><code>args[list]</code> a list of arguments that used to initialize nodes. Not for <code>call</code>.</p>
<p><code>docstring[string]</code> docstring</p>
<h3 id="example_5">Example</h3>
<pre><code class="language-lisp">(defsequence MLP (in-features)
    &quot;Docstring (optional)&quot;
    (LinearLayer in-features 512)
    (asnode #'!tanh)
    (LinearLayer 512 256)
    (asnode #'!tanh)
    (LinearLayer 256 10))

;; Sequence can receive a single argument.
(call (MLP 786) (randn `(10 786)))
</code></pre>
<p>Tips: Use <code>(sequencelist-nth n sequence-model)</code> to read the nth layer of sequence.</p>
<h2 id="macro-hooker">[macro] hooker</h2>
<pre><code class="language-lisp">(hooker bind optimizer)
</code></pre>
<p>A convenient macro to hook AbstractOptimizers to each AbstractTensor. As the most straightforward explanation: this macro is expanded into this form.</p>
<pre><code class="language-lisp">`(lambda (,bind)
     (hook-optimizer! ,bind ,optimizer))
</code></pre>
<p>where <code>bind</code> is excepted to be AbstractTensor, optimizer is a creation form of <code>AbstractOptimizer</code>, and the function <code>hook-optimizer!</code> hooks the given optimizer into bind.</p>
<p>In cl-waffe2, one independent Optimizer must be initialised per parameter. This macro can be used to concisely describe the process of initialising the same Optimiser for many parameters.</p>
<h3 id="example_6">Example</h3>
<pre><code class="language-lisp">;; (model-parameters compiled-composite) to read the list of all parameters in the network

(let ((model (build (!matmul 
             (parameter (randn `(3 3)))
             (parameter (randn `(3 3)))))))

  (mapc (hooker x (Adam X :lr 1e-3)) (model-parameters model))

  (forward model)
  (backward model)

  (mapc #'call-optimizer! (model-parameters model)))
</code></pre>
<h2 id="macro-node-lambda">[macro] node-&gt;lambda</h2>
<pre><code class="language-lisp">(node-&gt;lambda (&amp;rest where) &amp;body body)
</code></pre>
<p>Creates a lambda function obtained by tracing and compiling the computation node described in body.</p>
<h3 id="inputs_2">Inputs</h3>
<p><code>where</code> declares the shape transforms. the tensor names used here are the same as those used in body. (i.e.: everything is AbstractTensor)</p>
<p><code>body</code> Describe the construction of the computation node here.</p>
<h3 id="example_7">Example</h3>
<pre><code class="language-lisp">(node-&gt;lambda (A[~] -&gt; B[~])
    (!sin (!cos a)))

(funcall * (randn `(3 3)))
</code></pre>
<h3 id="note">Note</h3>
<p>⚠️ Caches of functions are created for each location where this macro is located. Never place it inside a loop!</p>
<h2 id="macro-node-defun">[macro] node-&gt;defun</h2>
<pre><code class="language-lisp">(node-&gt;defun (name (&amp;rest where) &amp;body body))
</code></pre>
<p>Defines a function obtained by tracing and compiling the computation node described in the body.</p>
<h3 id="inputs_3">Inputs</h3>
<p><code>name[symbol]</code> the function is defined after it</p>
<p><code>where</code> declares the shape transforms. the tensor names used here are the same as those used in body.</p>
<p><code>body</code> Describe the construction of the computation node here.</p>
<h3 id="example_8">Example</h3>
<pre><code class="language-lisp">(node-&gt;defun log-softmax (A[~] -&gt; OUT[~])
    (!softmax (!loge a) :axis 1))

(log-softmax (ax+b `(3 3) 0 1))
{CPUTENSOR[float] :shape (3 3) :id TID261835 
  ((0.33333334 0.33333334 0.33333334)
   (0.33333334 0.33333334 0.33333334)
   (0.33333334 0.33333334 0.33333334))
  :facet :input
  :belongs-to :memory-pool
  :requires-grad NIL
  :backward NIL}
</code></pre>
<h2 id="function-show-backends">[function] show-backends</h2>
<pre><code class="language-lisp">(show-backends &amp;key (stream t))
</code></pre>
<p>collects and displays the current state of devices to the given <code>stream</code></p>
<h3 id="example_9">Example</h3>
<pre><code class="language-lisp">(show-backends)

─────[All Backends Tree]──────────────────────────────────────────────────

[*]CPUTENSOR: OpenBLAS=available *simd-extension-p*=available
    └[-]JITCPUTENSOR: compiler=gcc flags=(-fPIC -O3 -march=native) viz=NIL

[*]LISPTENSOR: Common Lisp implementation on matrix operations
    └[-]JITLISPTENSOR: To be deleted in the future release. do not use this.

[-]SCALARTENSOR: is a special tensor for representing scalar values.
    └[-]JITCPUSCALARTENSOR: Use with JITCPUTensor

([*] : in use, [-] : not in use.)
Add a current-backend-state method to display the status.
─────[*using-backend*]───────────────────────────────────────────────────

Priority: Higher &lt;───────────────────&gt;Lower
                  CPUTENSOR LISPTENSOR 

(use with-devices macro or set-devices-toplevel function to change this parameter.)
</code></pre>
<h2 id="function-set-devices-toplevel">[function] set-devices-toplevel</h2>
<pre><code class="language-lisp">(set-devices-toplevel &amp;rest devices)
</code></pre>
<p>Declares devices to use.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../overview/" class="btn btn-neutral float-left" title="Learn More"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../nodes/" class="btn btn-neutral float-right" title="cl-waffe2/vm.nodes">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../overview/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../nodes/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
